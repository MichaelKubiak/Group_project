if(row.names(counts)[[i]] %in% genes[,1]){
positions<-append(i, positions)
}
}
genes[,1]
genes[1,1]
genes<- as.list(genes)
genes<- as.data.frame(genes)
for (i in 1:length(counts)){
if(row.names(counts)[[i]] %in% genes[,1]){
positions<-append(i, positions)
}
}
positions<-c()
for (i in 1:length(counts)){
if(row.names(counts)[[i]] %in% genes[,1]){
positions<-append(i, positions)
}
}
row.names(counts)[[292]]
row.names(counts)[[6]]
genes<- read.delim("genes",row.names=1,sep=" ")
positions<-c()
genes[5,1] %in% row.names(counts)
genes<- read.delim("genes",row.names=2,sep=" ")
for (i in 1:length(counts)){
if(row.names(counts)[[i]] %in% row.names(genes)){
positions<-append(i, positions)
}
}
row.names(genes)
"DAAM2" %in% row.names(counts)
for (i in 1:length(row.names(counts))){
if(row.names(counts)[[i]] %in% row.names(genes)){
positions<-append(i, positions)
}
}
positions<-c()
for (i in 1:length(row.names(counts))){
if(row.names(counts)[[i]] %in% row.names(genes)){
positions<-append(i, positions)
}
}
heatmap(as.matrix(counts), Rowv = positions)
merge(genes,counts)
merged<-merge(genes,counts)
view(merged)
View(merged)
merged<- rbind(genes,counts)
merged<- cbind(genes,counts)
merged<- bind(genes,counts)
library(dplyr)
merged<- intersect(genes,counts)
?intersect
genes$row.names<-NULL
merged<- counts[genes,]
merged<-data.frame()
common<-instersect(row.names(counts),row.names(genes))
common<-intersect(row.names(counts),row.names(genes))
merged<-counts[common,]
heatmap(as.matrix(merged))
View(merged)
library(plotly)
plot_ly(merged,type="heatmap")
plot_ly(z=merged,type="heatmap")
plot_ly(z=as.matrix(merged),type="heatmap")
plot_ly(as.matrix(merged),type="heatmap")
plot_ly(merged,type="heatmap")
heatmap(as.matrix(merged),scale="row")
heatmap(as.matrix(merged),scale="column")
heatmap(as.matrix(merged),scale="row")
heatmap(as.matrix(merged),scale="column")
heatmap.2(as.matrix(merged),scale="column")
library(ggplots)
library(gplots)
install.packages("gplots")
counts<-read.delim("../adult_cells", row.names=1,header=TRUE,sep="\t", strip.white = TRUE)
common<-intersect(row.names(counts),row.names(genes))
merged<-counts[common,]
heatmap(as.matrix(merged), )
heatmap(as.matrix(merged), scale="rows")
heatmap(as.matrix(merged), scale="row")
heatmap.2(as.matrix(merged), scale="row")
library(gplots)
heatmap.2(as.matrix(merged), scale="row")
heatmap.2(merged, scale="row")
heatmap.2(as.matrix(merged), scale="row")
heatmap.2(as.matrix(merged))
heatmap(as.matrix(merged), scale="row")
heatmap(as.matrix(merged), scale="row",Rowv=1)
heatmap(as.matrix(merged), scale="row")
heatmap(as.matrix(merged), scale="row", col = bluered(100))
heatmap(as.matrix(merged), scale="row",Rowv=rowMeans(merged))
heatmap(as.matrix(merged), scale="row", col = bluered(100))
heatmap(as.matrix(merged), scale="row", col = bluered(100))
heatmap(as.matrix(merged), scale="row", col = bluered(100))
svg(filename="heatmap.svg",width=20,height = 20,pointsize = 10)
heatmap(as.matrix(merged), scale="row", col = bluered(100))
dev.off()
countsn<-as.data.frame(read.delim("../neurons","\t",header=TRUE,row.names=1))
counts<-as.data.frame(read.delim("../foetal_cells","\t", header=TRUE, row.names = 1))
library(FactoMineR)
library(rgl)
countsm<- merge(counts,countsn, by=0,all=TRUE)
View(countsm)
counts<- merge(counts,countsn, by=0,all=TRUE)
row.names(counts)<- counts$Row.names
counts$Row.names <- NULL
View(counts)
# filter the count matrix, removing cells with fewer than 1800 genes, genes with fewer than 1 read, and genes that are not detected in any cells
counts <- clean.counts(counts, min.lib.size=1800, min.reads = 1,min.detected = 1)
library(argparse)
library(parallel)
library(scde)
library(tsne)
library(mclust)
library(igraph)
library(FactoMineR)
# filter the count matrix, removing cells with fewer than 1800 genes, genes with fewer than 1 read, and genes that are not detected in any cells
counts <- clean.counts(counts, min.lib.size=1800, min.reads = 1,min.detected = 1)
# build error models
models <- scde.error.models(counts, n.cores=4,threshold.segmentation = TRUE, save.crossfit.plots = FALSE, save.model.plots = FALSE)
read.graph(ftree, "../1_Original_pipeline/Foetal/ftree")
alarm()
alarm()
alarm()
alarm()
alarm()
alarm()
alarm()
# keep only valid cells (where their correlation is positive) in the models
valid.cells<-models$corr.a > 0
models <- models[valid.cells,]
# calculate the prior distribution of genes
prior <- scde.expression.prior(models, counts)
# estimate the drop-out probability for each cell
p.self.fail <- scde.failure.probability(models, counts = counts)
# perform simulations to determine the most likely expression distances between cells
# set variables
n.simulations <- 1000
k<-0.9
cell.names <- colnames(counts)
names(cell.names) <- cell.names
# define the direct dropout simulation function
simulate <- function(i){
scd1 <- do.call(cbind,lapply(cell.names,function(nam){
x <- counts[,nam];
x[!as.logical(rbinom(length(x),1,1-p.self.fail[,nam]*k))] <- NA;
x;
}))
rownames(scd1) <- rownames(counts)
cor(log10(scd1+1),use="pairwise.complete.obs")
}
# perform the direct dropout simulations using 4 cores
dl<-mclapply(1:n.simulations,simulate, mc.cores = 4)
# produce an expression distance matrix for the cells
direct.dist.mat <- 1-Reduce("+",dl)/length(dl)
pca<-PCA(direct.dist.mat)
plot3d(pca$ind$coord[,1:3])
plot3d(pca$var$contrib)
plot3d(pca$var$cor)
install.packages(""shiny"")
install.packages("shiny")
library(shiny)
#shiny app
library(shiny)
ui<-shinyUI(pageWithSidebar(
headerPanel("Test shiny page")
sidebarPanel(
radioButtons("thing",
"Things",
choices = c("A","B","C")))
))
#shiny app
library(shiny)
ui<-shinyUI(pageWithSidebar(
headerPanel("Test shiny page")
sidebarPanel=radioButtons("thing",
"Things",
choices = c("A","B","C"))
))
#shiny app
library(shiny)
ui<-shinyUI(pageWithSidebar(
headerPanel("Test shiny page"),
sidebarPanel(radioButtons("thing",
"Things",
choices = c("A","B","C")))
))
#shiny app
library(shiny)
ui<-shinyUI(pageWithSidebar(
headerPanel("Test shiny page"),
sidebarPanel(radioButtons("thing",
"Things",
choices = c("A","B","C"))),
mainPanel()
))
ui
plot3d(pca$ind[,1:3])
plot3d(pca$ind$coord[,1:3])
plot3d(pca$eig)
plot3d(pca$var$contrib)
dimdesc(pca)
dimdesc(pca$var)
plot3d(T(pca))
plot3d(t(pca))
pca<-PCA(t(direct.dist.mat)
plot3d(pca)
write.csv(pca)
}
pca<-PCA(t(direct.dist.mat))
plot3d(pca)
plot3d(pca$var$coord)
plot3d(pca$ind$coord)
dimdesc(pca)
dimdesc(t(pca))
dimdesc(pca$var)
counts[nongene,]<-NULL
nongene<-c("no_feature","ambiguous","alignment_not_unique")
counts[nongene,]<-NULL
tail counts
tail (counts)
arguments<-parser$parse_args("../neurons")
parser<-ArgumentParser(description="performs analysis through the pipeline outlined in Darmanis et al")
parser$add_argument("Input",help="The file to be read")
parser$add_argument("--clustering", "-c", action="store_true", help="perform the clustering section")
parser$add_argument("--spanning", "-s", action="store_true", help="perform the spanning tree section")
parser$add_argument("--pca","-p", action="store_true", help="perform the pca section")
arguments<-parser$parse_args("../neurons")
# read in expression count matrix
counts<-read.delim(arguments$Input,sep="\t",header = TRUE, row.names=1)
tail(counts)
nongene<-c("no_feature","ambiguous","alignment_not_unique")
counts[nongene,]<-NULL
tail(counts)
tail(counts)
counts[nongene,]<-NULL
# read in expression count matrix
counts<-read.delim(arguments$Input,sep="\t",header = TRUE, row.names=1)
tail(counts)
counts<- counts - counts[nongene,]
counts<- counts[!rownames(counts) %in% nongene,]
tail(counts)
nongene<-c("no_feature ","ambiguous ","alignment_not_unique ")
counts<- counts[!rownames(counts) %in% nongene,]
tail(counts)
dist.mat<-read.delim("distance_matrix_for_pca",sep="\t",row.names=1,header=TRUE)
write.csv(direct.dist.mat,"distance_matrix_for_pca",sep="\t")
write.csv(direct.dist.mat,"distance_matrix_for_pca")
dist.mat<-read.delim("distance_matrix_for_pca",sep="\t",row.names=1,header=TRUE)
dist.mat<-read.delim("distance_matrix_for_pca",row.names=1,header=TRUE)
write.table(direct.dist.mat,"distance_matrix_for_pca",sep="\t")
dist.mat<-read.delim("distance_matrix_for_pca",row.names=1,header=TRUE,sep="\t")
parser$add_argument("--cores","-c", help="how many cores to use")
arguments<-parser$parse_args()
parser$add_argument("--cores","-r", help="how many cores to use")
arguments<-parser$parse_args()
View(counts)
View(arguments)
remove(parser)
parser<-ArgumentParser(description="performs analysis through the pipeline outlined in Darmanis et al")
library(argparse)
parser<-ArgumentParser(description="performs analysis through the pipeline outlined in Darmanis et al")
parser$add_argument("Input",help="The file to be read")
parser$add_argument("--clustering", "-c", action="store_true", help="perform the clustering section")
parser$add_argument("--spanning", "-s", action="store_true", help="perform the spanning tree section")
parser$add_argument("--pca","-p", action="store_true", help="perform the pca section")
parser$add_argument("--cores","-r", help="how many cores to use")
arguments<-parser$parse_args()
arguments<-parser$parse_args("combined_data")
parser$add_argument("--cores","-r", default=4,help="how many cores to use")
arguments<-parser$parse_args("combined_data")
parser$add_argument("-cores", "-r", default = 4,help="the number of cores to use")
args<-parser$parse_args()
parser<-ArgumentParser(description="performs analysis through the pipeline outlined in Darmanis et al")
parser$add_argument("adult_neurons", help="The adult neurons")
parser$add_argument("foetal_q", help="The foetal quiescent cells")
library(argparse)
parser<-ArgumentParser(description="performs analysis through the pipeline outlined in Darmanis et al")
parser$add_argument("adult_neurons", help="The adult neurons")
parser$add_argument("foetal_q", help="The foetal quiescent cells")
parser$add_argument("foetal_r", help="The foetal replicating cells")
parser$add_argument("-cores", "-r", default = 4,help="the number of cores to use")
args<-parser$parse_args()
system(paste0("Rscript ./scde_analysis.R all_neurons -p -r ", args$cores))
parser$add_argument("--cores", "-r", default = 4,type=int, help="the number of cores to use")
parser$add_argument("--cores", "-r", default = 4,type=integer, help="the number of cores to use")
z.cols <- cut(z, 3, labels = c("pink", "green", "yellow"))
cols <- cut(z, 3, labels = c("pink", "green", "yellow"))
z.cols <- cut(dist.mat, 3, labels = c("pink", "green", "yellow"))
z<-rnorm(100)
z.cols <- cut(z, 3, labels = c("pink", "green", "yellow"))
z.cols
remove(z.cols)
remove(z)
cols <-list()
for (i in 1:length(colnames(dist.mat))){
if (colnames(dist.mat)[[i]] %in% row.names(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% row.names(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
ad<-as.data.frame(read.delim(args$adult_neurons,row.names=1,header=TRUE))
ad<-as.data.frame(read.delim("../adult_cells",row.names=1,header=TRUE))
fq<-as.data.frame(read.delim("foetal_cells_quiescent", row.names=1,header=TRUE))
fr<-as.data.frame(read.delim("foetal_cells_replicating",row.names=1,header=TRUE))
for (i in 1:length(colnames(dist.mat))){
if (colnames(dist.mat)[[i]] %in% row.names(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% row.names(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
pca<-PCA(t(dist.mat))
library(FactoMineR)
pca<-PCA(t(dist.mat))
plot3d(pca$ind$coord, col = as.character(cols))
library(rgl)
plot3d(pca$ind$coord, col = as.character(cols))
for (i in 1:length(colnames(dist.mat))){
breakpoint()
if (colnames(dist.mat)[[i]] %in% row.names(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% row.names(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
for (i in 1:length(colnames(dist.mat))){
breakpoint
if (colnames(dist.mat)[[i]] %in% row.names(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% row.names(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
for (i in 1:length(colnames(dist.mat))){
print(i)
if (colnames(dist.mat)[[i]] %in% row.names(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% row.names(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
for (i in 1:length(colnames(dist.mat))){
print(i)
print(colnames(dist.mat)[[i]])
if (colnames(dist.mat)[[i]] %in% row.names(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% row.names(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
print(row.names(ad))
print(colnames(ad))
for (i in 1:length(colnames(dist.mat))){
if (colnames(dist.mat)[[i]] %in% colnames(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% colnames(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
pca<-PCA(t(dist.mat))
plot3d(pca$ind$coord, col = as.character(cols))
print(colnames(dist.mat)[[i]])
for (i in 1:length(colnames(dist.mat))){
print(colnames(dist.mat)[[i]] %in% in colnames(ad))
if (colnames(dist.mat)[[i]] %in% colnames(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% colnames(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
for (i in 1:length(colnames(dist.mat))){
print(colnames(dist.mat)[[i]] %in% colnames(ad))
if (colnames(dist.mat)[[i]] %in% colnames(ad)){
append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% colnames(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
for (i in 1:length(colnames(dist.mat))){
print(colnames(dist.mat)[[i]] %in% colnames(ad))
if (colnames(dist.mat)[[i]] %in% colnames(ad)){
append("blue", cols)
}
else if(colnames(dist.mat)[[i]] %in% colnames(fq)){
append(cols,"red")
}else{
append(cols,"orange")
}
}
for (i in 1:length(colnames(dist.mat))){
if (colnames(dist.mat)[[i]] %in% colnames(ad)){
cols<-append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% colnames(fq)){
cols<-append(cols,"red")
}else{
cols<-append(cols,"orange")
}
}
plot3d(pca$ind$coord, col = as.character(cols))
ad<-as.data.frame(read.delim("../adult_cells",row.names=1,header=TRUE))
fq<-as.data.frame(read.delim("foetal_cells_quiescent", row.names=1,header=TRUE))
fr<-as.data.frame(read.delim("foetal_cells_replicating",row.names=1,header=TRUE))
cols <-list()
for (i in 1:length(colnames(dist.mat))){
if (colnames(dist.mat)[[i]] %in% colnames(ad)){
cols<-append(cols, "blue")
}
else if(colnames(dist.mat)[[i]] %in% colnames(fq)){
cols<-append(cols,"red")
}else{
cols<-append(cols,"orange")
}
}
rm(list=setdiff(ls(), c("cols", "pca")))
setwd ("../Website/R")
save.image(file = "pca_data.RData")
runApp()
library(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
?axes3d
?axes3d$edges
?bbox3d
?bbox3d$xunit
?xunit
??xunit
plot3d(pca$ind$coord, col = as.character(cols))
plot3d(pca$ind$coord, col = as.character(cols))
pp<-par3d(no.readonly=TRUE)
save.image("~/Course_Material/BS7120/Group_project/Group_project/Website/R/pca_data.RData")
runApp()
plot3d(pca$ind$coord, col = as.character(cols))
par3d(pp)
pp<-par3d()
plot3d(pca$ind$coord, col = as.character(cols))
pp<-par3d()
runApp()
plot3d(pca$ind$coord, col = as.character(cols))
pp<-par3d()
pp<-par3d()
plot3d(pca$ind$coord, col = as.character(cols))
par3d(pp)
plot3d(pca$ind$coord, col = as.character(cols))
plot3d(pca$ind$coord, col = as.character(cols))
par3d(pp)
pcaplot<-plot3d(pca$ind$coord, col = as.character(cols))
print(pcaplot)
function(input,output){
output$plot1<-renderRglwidget({
try(rgl.close())
plot3d(pca$ind$coord, col = as.character(cols))
par3d(pp$viewport)
rglwidget()
})
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
par3d(pp$bbox)
runApp()
par3d(bbox = pp$bbox)
runApp()
runApp()
plot3d(pca$ind$coord, col = as.character(cols))
pp<-par3d(no.readonly=TRUE)
rm(pcaplot)
load("~/Course_Material/BS7120/Group_project/Group_project/Website/R/pca_data.RData")
runApp()
runApp()
runApp()
